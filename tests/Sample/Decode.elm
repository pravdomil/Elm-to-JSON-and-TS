module Sample.Decode exposing (..)

{-| Generated by elm-json-interop.
-}

import Json.Decode as D exposing (Decoder)
import Sample as A
import Sample2.Decode as Sample2 exposing (sampleType)
import Utils.Json.Decode_ as D_


type0 : Decoder A.Type0
type0 =
    D.field "_" D.int
        |> D.andThen
            (\i___ ->
                case i___ of
                    0 ->
                        D.succeed A.Type0

                    _ ->
                        D.fail ("I can't decode " ++ "Type0" ++ ", unknown variant with index " ++ String.fromInt i___ ++ ".")
            )


type1 : Decoder A.Type1
type1 =
    D.field "_" D.int
        |> D.andThen
            (\i___ ->
                case i___ of
                    0 ->
                        D.map A.Type1 (D.field "a" D.string)

                    _ ->
                        D.fail ("I can't decode " ++ "Type1" ++ ", unknown variant with index " ++ String.fromInt i___ ++ ".")
            )


type2 : Decoder A.Type2
type2 =
    D.field "_" D.int
        |> D.andThen
            (\i___ ->
                case i___ of
                    0 ->
                        D.map2 A.Type2 (D.field "a" D.string) (D.field "b" D.string)

                    _ ->
                        D.fail ("I can't decode " ++ "Type2" ++ ", unknown variant with index " ++ String.fromInt i___ ++ ".")
            )


type10 : Decoder A.Type10
type10 =
    D.field "_" D.int
        |> D.andThen
            (\i___ ->
                case i___ of
                    0 ->
                        D_.map10 A.Type10 (D.field "a" D.string) (D.field "b" D.string) (D.field "c" D.string) (D.field "d" D.string) (D.field "e" D.string) (D.field "f" D.string) (D.field "g" D.string) (D.field "h" D.string) (D.field "i" D.string) (D.field "j" D.string)

                    _ ->
                        D.fail ("I can't decode " ++ "Type10" ++ ", unknown variant with index " ++ String.fromInt i___ ++ ".")
            )


record0 : Decoder A.Record0
record0 =
    D.succeed {}


record1 : Decoder A.Record1
record1 =
    D.map (\a -> { a1 = a }) (D.field "a1" D.string)


record2 : Decoder A.Record2
record2 =
    D.map2 (\a b -> { a1 = a, a2 = b }) (D.field "a1" D.string) (D.field "a2" D.string)


record10 : Decoder A.Record10
record10 =
    D_.map10 (\a b c d e f g h i j -> { a1 = a, a2 = b, a3 = c, a4 = d, a5 = e, a6 = f, a7 = g, a8 = h, a9 = i, a10 = j }) (D.field "a1" D.string) (D.field "a2" D.string) (D.field "a3" D.string) (D.field "a4" D.string) (D.field "a5" D.string) (D.field "a6" D.string) (D.field "a7" D.string) (D.field "a8" D.string) (D.field "a9" D.string) (D.field "a10" D.string)


typeUnqualified : Decoder A.TypeUnqualified
typeUnqualified =
    sampleType


typeQualified : Decoder A.TypeQualified
typeQualified =
    Sample2.sampleType


sample aDecoder bDecoder cDecoder =
    D_.map15 (\a b c d e f g h i j k l m n o -> { unit = a, bool = b, int = c, float = d, char = e, string = f, list = g, array = h, maybe = i, result = j, set = k, dict = l, tuple = m, tuple3 = n, record = o }) (D.field "unit" D_.unit) (D.field "bool" D.bool) (D.field "int" D.int) (D.field "float" D.float) (D.field "char" D_.char) (D.field "string" D.string) (D.field "list" (D.list aDecoder)) (D.field "array" (D.array aDecoder)) (D_.maybeField "maybe" (D_.maybe aDecoder)) (D.field "result" (D_.result aDecoder bDecoder)) (D.field "set" (D_.set aDecoder)) (D.field "dict" (D_.dict aDecoder bDecoder)) (D.field "tuple" (D_.tuple aDecoder bDecoder)) (D.field "tuple3" (D_.tuple3 aDecoder bDecoder cDecoder)) (D.field "record" (D.succeed {}))
